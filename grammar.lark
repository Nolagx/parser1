// TODO some definitions use a regular expression to make a list, for example name_list.
// this might cause issues in the semantic check, depending on how lark handles passing the
// tokens in the regex to a function, might have to change the regular expressions to recursive
// list definitions.

?start: (statement _NEWLINE)* (statement)?

?statement: relation_declaration
      | fact
      | rule
      | query
      | assign_string
      | assign_span

assign_string: name "=" string -> assign_normal_string
             | name "=" "read" "(" string ")" -> assign_string_from_file_string_param
             | name "=" "read" "(" name ")" -> assign_string_from_file_var_param

assign_span: name "=" span

relation_declaration: "new" name "(" decl_term ("," decl_term)* ")"

?decl_term: "str" -> decl_string
          | "spn" -> decl_span

rule: rule_head "<-" rule_body_relation ("," rule_body_relation)*

// without "rule" we will get a shift/reduce conflict with relation
rule_head: name "(" name_list ")"

rule_body_relation: relation -> rule_body_normal_relation
                  | rgx_relation -> rule_body_rgx_relation
                  | ie_relation -> rule_body_ie_relation

fact: relation

query: "?" relation

relation: name "(" term ("," term)* ")"

?term: span
     | string
     | name

// TODO string means we don't check for a valid regex here, leave it to the regex engine?
rgx_relation: "extract" "RGX" "<" string ">" "(" name_list ")" "from" name

ie_relation: name "<" name ">" "(" name_list ")"

span: "[" int "," int ")"

?int: INT -> integer

?string: STRING

?name_list: name ("," name)*

?name: NAME

// CNAME: ("_"|LETTER) ("_"|LETTER|DIGIT)*
%import common.CNAME -> NAME
%import common.WS_INLINE
%ignore WS_INLINE
%import common.ESCAPED_STRING -> STRING
%import common.INT -> INT
%import common.NEWLINE -> _NEWLINE